# Python code to help generate all the leader-making traits code
import argparse
from datetime import datetime
import os
import time
import sys
from json import load as json_load

from generate_trait_tooltips import create_tooltip_for_leader
from mre_common_vars import (
    BUILD_FOLDER,
    INPUT_FILES_FOR_CODEGEN,
    LEADER_MAKING,
    CORE_MODIFYING,
    LEADER_SUBCLASSES,
    LEADER_CLASSES,
)

RARITIES = ("common", "veteran", "paragon")

AUTOGENERATED_HEADER = f"""
######################################
# AUTOGENERATED on {str(datetime.now())}                #
######################################
"""

gui_header = """
##########################################################
#       START COPY/PASTE GENERATED GUI TRAITS CODE FOR:  #
#					{classname}						 #
#   generated on {now}
##########################################################
"""
gui_footer = """
##########################################################
#       END COPY/PASTE GENERATED GUI TRAITS CODE FOR:  #
#					{classname}						 #
##########################################################
"""

def gen_core_modifying_gui_subclass_pickers_code():
    return """
#subclass_general_marshall
    containerWindowType = {
        name = "xvcv_mdlc_core_modifying_traits_general_subclass_general_marshall"
        position = { x = @xvcv_mdlc_core_modifying_trait_position_width_3 y = @xvcv_mdlc_core_modifying_trait_position_height_1 }
        effectbuttonType = {
            name = "xvcv_mdlc_core_modifying_traits_general_subclass_general_marshall_add"
            position = { x = @xvcv_mdlc_core_modifying_subclass_traits_offset_width y = @xvcv_mdlc_core_modifying_subclass_traits_offset_height }
            spriteType = "GFX_leader_subclass_commander_general_medium"
            effect = "xvcv_mdlc_core_modifying_traits_general_subclass_general_marshall_add_button_effect"
        }
        effectbuttonType = {
            name = "xvcv_mdlc_core_modifying_traits_general_subclass_general_marshall_remove"
            position = { x = @xvcv_mdlc_core_modifying_subclass_traits_offset_width y = @xvcv_mdlc_core_modifying_subclass_traits_offset_height }
            spriteType = "GFX_xvcv_mdlc_leader_subclass_visionary_medium_red"
            effect = "xvcv_mdlc_core_modifying_traits_general_subclass_general_marshall_remove_button_effect"
        }
    }
"""

### LEADER_MAKING

def gen_leader_making_trait_gui_code(
        leader_class, trait_name, column_num, row_num,
        gfx_sprite_name=None,
        is_xvcv_custom_trait=False, is_veteran_trait=False, is_destiny_trait=False
):
    """ Create code to display a trait in the xvcv_mdlc_leader_making_custom_gui.gui file """
    if not gfx_sprite_name:
        # Guess GFX name from trait name
        ends_in_num = trait_name[-1].isdigit()
        if ends_in_num:
            trait_without_level = trait_name.rsplit('_', 1)
            gfx_sprite_name = f"GFX_{trait_without_level}"
        else:
            gfx_sprite_name = f"GFX_{trait_name}"  # There will be exceptions
    effect_button_background_gfx = "GFX_xvcv_mdlc_leader_trait_background_green"
    if is_xvcv_custom_trait:
        effect_button_background_gfx = "GFX_xvcv_mdlc_leader_trait_background_blue"
    elif is_veteran_trait:
        effect_button_background_gfx = "GFX_xvcv_mdlc_leader_trait_background_veteran"
    elif is_destiny_trait:
        effect_button_background_gfx = "GFX_xvcv_mdlc_leader_trait_background_destiny"
    return f"""
# {leader_class}: {trait_name}
containerWindowType = {{
    name = "xvcv_mdlc_leader_making_trait_{leader_class}_{trait_name}"
    position = {{ x = @xvcv_mdlc_leader_making_trait_position_column_{column_num} y = @xvcv_mdlc_leader_making_trait_position_row_{row_num} }}
    effectbuttonType = {{
        name = "xvcv_mdlc_leader_making_trait_{leader_class}_{trait_name}_add_bg"
        position = {{ x = @xvcv_mdlc_leader_making_traits_background_offset_width y = @xvcv_mdlc_leader_making_traits_background_offset_height }}
        spriteType = "{effect_button_background_gfx}"
        effect = "xvcv_mdlc_leader_making_trait_{leader_class}_{trait_name}_add_button_effect"
    }}
    effectbuttonType = {{
        name = "xvcv_mdlc_leader_making_trait_{leader_class}_{trait_name}_add"
        spriteType = "{gfx_sprite_name}"
        effect = "xvcv_mdlc_leader_making_trait_{leader_class}_{trait_name}_add_button_effect"
    }}
}}
"""

def gen_leader_making_button_effects_code(
    leader_class, trait_name,
    is_veteran_trait=False, is_destiny_trait=False,
    required_subclass=None
):
    # This can be used for each leader class
    # \common\button_effects\xvcv_mdlc_button_effects_leader_making_<LEADER_CLASS>_customgui.txt
    needs_paragon_dlc = "yes" if is_veteran_trait or is_destiny_trait else "no"
    # Veteran & destinty traits need slightly altered trigger names
    alt_trigger_name = ""
    if is_veteran_trait:
        alt_trigger_name = "alt_"
    if is_destiny_trait:
        alt_trigger_name = "alt_2_"
    # Comment out the 'requires_leader_subclass_trigger` if it's not a veteran trait'
    requires_subclass_trigger = "" if required_subclass else "#"
    # commend out skill level trigger if it's not a veteran trait
    requires_skill_lvl_trigger = "" if is_veteran_trait or is_destiny_trait else "#"
    show_veteran_comment = f"#veteran trait" if is_veteran_trait else ''
    return f"""
#{leader_class} #{trait_name} {show_veteran_comment}
xvcv_mdlc_leader_making_trait_{leader_class}_{trait_name}_add_button_effect = {{
    potential = {{ always = yes }}
    allow = {{
        xvcv_mdlc_leader_making_trait_pick_trigger = {{ CLASS = {leader_class} ID = {trait_name} }}
        {requires_subclass_trigger}xvcv_mdlc_leader_making_requires_leader_subclass_trigger = {{ CLASS = {leader_class} ID = {required_subclass} }}
        xvcv_mdlc_leader_making_trait_cost_{alt_trigger_name}trigger = yes
        xvcv_mdlc_leader_making_trait_points_{alt_trigger_name}trigger = yes
        {requires_skill_lvl_trigger}xvcv_mdlc_leader_making_trait_skill_level_{alt_trigger_name}trigger = yes
        xvcv_mdlc_leader_making_trait_max_number_trigger = yes
        xvcv_mdlc_leader_making_picked_class_{leader_class}_trigger = yes
    }}
    effect = {{
        xvcv_mdlc_leader_making_trait_pick_effect = {{ CLASS = {leader_class} ID = {trait_name} }}
        hidden_effect = {{ xvcv_mdlc_leader_making_trait_count_points_costs_{alt_trigger_name}effect = yes }}
    }}
}}
"""

def iterate_traits_make_leadermaking_gui_code(organized_traits_dict, for_class: str) -> str:
    """ going thru a file like 99_mre_scientist_traits_for_codegen.json 
        and create code which we copy/paste into the interface/gui files
    """
    header_classname_spaced = ' '.join([char for char in for_class])
    header = gui_header.format(
        classname=header_classname_spaced,
        now=str(datetime.now())
    )
    footer = gui_footer.format(
        classname=header_classname_spaced
    )
    leader_making_code_bloblist = [header,]
    # 10 columns, 8 rows
    trait_column_num = 1
    trait_row_num = 1
    for rarity_level in RARITIES:
        for leader_making_trait in organized_traits_dict['leader_making_traits'][rarity_level]:
            trait_name = [*leader_making_trait][0]
            root = leader_making_trait[trait_name]
            trait_gui_code = gen_leader_making_trait_gui_code(
                trait_name=trait_name,
                leader_class=root['leader_class'],
                column_num=trait_column_num, row_num=trait_row_num,
                is_veteran_trait=(root['rarity']=="veteran"),
                is_destiny_trait=(root['rarity']=="paragon"),
                gfx_sprite_name=root['gfx']
            )
            trait_column_num = trait_column_num + 1
            if trait_column_num > 10:
                trait_column_num = 1
                trait_row_num = trait_row_num + 1
            leader_making_code_bloblist.append(trait_gui_code)
    leader_making_code_bloblist.append(footer)
    return ''.join(leader_making_code_bloblist)

def iterate_traits_make_leadermaking_tooltips_code(organized_traits_dict, for_class):
    leader_making_tooltips_copypaste_blob = [AUTOGENERATED_HEADER]
    for rarity_level in RARITIES:
        for leader_making_trait in organized_traits_dict['leader_making_traits'][rarity_level]:
            tooltip_code_for_leadermaking_trait = create_tooltip_for_leader(
                trait_dict=leader_making_trait, leader_class=for_class, feature="core_modifying"
            )
            leader_making_tooltips_copypaste_blob.append(tooltip_code_for_leadermaking_trait)
    return ''.join(leader_making_tooltips_copypaste_blob)

def iterate_traits_make_leadermaking_effects_code(organized_traits_dict, for_class):
    leader_making_effects_copypaste_blob = [AUTOGENERATED_HEADER]
    for rarity_level in RARITIES:
        for leader_making_trait in organized_traits_dict['leader_making_traits'][rarity_level]:
            trait_name = [*leader_making_trait][0]
            root = leader_making_trait[trait_name]
            leadermaking_effects_code_for_trait = gen_leader_making_button_effects_code(
                leader_class=for_class,
                trait_name=trait_name,
                is_veteran_trait=(root.get('rarity')=="veteran"),
                is_destiny_trait=(root.get('rarity')=="paragon"),
                required_subclass=root.get('required_subclass', None)
            )
            leader_making_effects_copypaste_blob.append(leadermaking_effects_code_for_trait)
    return '\n'.join(leader_making_effects_copypaste_blob)

def write_leadermaking_tooltips_to_file(input_codegen_json_file_name: str):
    # Open up 99_mre_<leaderclass>traits_for_codegen.json and write tooltips for a class
    buffer = ''
    base_filename =  input_codegen_json_file_name.rsplit('.',1)
    leadermaking_tt_filename = f"{base_filename}_leadermaking_tooltips.txt"
    output_file_name = os.path.join(
        BUILD_FOLDER,
        leadermaking_tt_filename
    )
    with open(input_codegen_json_file_name, "w") as source_codegen_data:
        buffer = json_load(source_codegen_data)
    detected_leader_class = input_codegen_json_file_name('_')[2]
    tooltips_blob_for_writing = iterate_traits_make_leadermaking_tooltips_code(
        buffer, for_class=detected_leader_class)
    with open(output_file_name, "wb") as leadermaking_effects_output:
        sys.stdout.write(f"Writing {detected_leader_class} leadermaking tooltips code to {leadermaking_effects_output.name}\n")
        leadermaking_effects_output.write(
            tooltips_blob_for_writing.encode('utf-8')
        )

def write_leadermaking_button_effects_to_file(input_codegen_json_file_name):
    buffer = ''
    base_filename =  input_codegen_json_file_name.rsplit('.',1)
    leadermaking_button_effects_outfile = f"{base_filename}_leadermaking_tooltips.txt"
    output_file_name = os.path.join(
        BUILD_FOLDER,
        leadermaking_button_effects_outfile
    )
    with open(input_codegen_json_file_name, "w") as source_codegen_data:
        buffer = json_load(source_codegen_data)
    detected_leader_class = input_codegen_json_file_name('_')[2]
    tooltips_blob_for_writing = iterate_traits_make_leadermaking_effects_code(
        buffer, for_class=detected_leader_class)
    with open(output_file_name, "wb") as leadermaking_effects_output:
        sys.stdout.write(f"Writing {detected_leader_class} leadermaking tooltips code to {leadermaking_effects_output.name}\n")
        leadermaking_effects_output.write(
            tooltips_blob_for_writing.encode('utf-8')
        )

def run_codegen_process_for_leadermaking_feature(input_codegen_json_file_name, generated_code_type="tooltips"):
    """ generated_code_types are "effects","gui","tooltips" """
    buffer = ''
    base_filename =  input_codegen_json_file_name.rsplit('.',1)[0]
    leadermaking_code_outfile = f"{base_filename}_leadermaking_{generated_code_type}.txt"
    output_file_name = os.path.join(
        BUILD_FOLDER,
        leadermaking_code_outfile
    )
    input_file_path = os.path.join(BUILD_FOLDER, input_codegen_json_file_name)
    # breakpoint()
    with open(input_file_path, "r") as source_codegen_data:
        buffer = json_load(source_codegen_data)
    detected_leader_class = input_codegen_json_file_name.split('_')[2]
    generated_leadermaking_code_blob = ''
    if generated_code_type == "tooltips":
        generated_leadermaking_code_blob = iterate_traits_make_feature_tooltips_code(
            buffer, for_class=detected_leader_class, feature="leader_making")
    elif generated_code_type == "gui":
        generated_leadermaking_code_blob = iterate_traits_make_leadermaking_gui_code(
            buffer, for_class=detected_leader_class)
    elif generated_code_type == "effects":
        generated_leadermaking_code_blob = iterate_traits_make_leadermaking_effects_code(
            buffer, for_class=detected_leader_class)
    with open(output_file_name, "wb") as leadermaking_code_outfile:
        sys.stdout.write(f"Writing {detected_leader_class} leadermaking {generated_code_type} code to {output_file_name}\n")
        leadermaking_code_outfile.write(
            generated_leadermaking_code_blob.encode('utf-8')
        )

### CORE_MODIFYING ###
def gen_core_modifying_trait_gui_code(
    leader_class, trait_name, column_num, row_num,
    gfx_sprite_name,
    is_xvcv_custom_trait=False, is_veteran_trait=False, is_destiny_trait=False
):
    root_gfx_name = "GFX_xvcv_mdlc_leader_trait_background_"
    effect_button_background_gfx = f"{root_gfx_name}_green"
    effect_button_background_gfx_red = f"{root_gfx_name}_red"
    if is_veteran_trait:
        effect_button_background_gfx = "GFX_xvcv_mdlc_leader_trait_background_veteran"
        effect_button_background_gfx_red = f"{effect_button_background_gfx}_red"
    elif is_destiny_trait:
        effect_button_background_gfx = "GFX_xvcv_mdlc_leader_trait_background_destiny"
        effect_button_background_gfx_red = f"{effect_button_background_gfx}_red"
    return f"""
# {leader_class}: {trait_name}
containerWindowType = {{
    name = "xvcv_mdlc_core_modifying_traits_{leader_class}_{trait_name}"
    position = {{ x = @xvcv_mdlc_core_modifying_trait_position_width_{column_num} y = @xvcv_mdlc_core_modifying_trait_position_height_{row_num} }}
    effectbuttonType = {{
        name = "xvcv_mdlc_core_modifying_traits_{leader_class}_{trait_name}_add_bg"
        position = {{ x = @xvcv_mdlc_core_modifying_traits_background_offset_width y = @xvcv_mdlc_core_modifying_traits_background_offset_height }}
        spriteType = "{effect_button_background_gfx}"
        effect = "xvcv_mdlc_core_modifying_traits_{leader_class}_{trait_name}_add_button_effect"
    }}
    effectbuttonType = {{
        name = "xvcv_mdlc_core_modifying_traits_{leader_class}_{trait_name}_add"
        spriteType = "{gfx_sprite_name}"
        effect = "xvcv_mdlc_core_modifying_traits_{leader_class}_{trait_name}_add_button_effect"
    }}
    effectbuttonType = {{
        name = "xvcv_mdlc_core_modifying_traits_{leader_class}_{trait_name}_remove_bg"
        position = {{ x = @xvcv_mdlc_core_modifying_traits_background_offset_width y = @xvcv_mdlc_core_modifying_traits_background_offset_height }}
        spriteType = "{effect_button_background_gfx_red}"
        effect = "xvcv_mdlc_core_modifying_traits_{leader_class}_{trait_name}_remove_button_effect"
    }}
    effectbuttonType = {{
        name = "xvcv_mdlc_core_modifying_traits_{leader_class}_{trait_name}_remove"
        spriteType = "{gfx_sprite_name}"
        effect = "xvcv_mdlc_core_modifying_traits_{leader_class}_{trait_name}_remove_button_effect"
    }}
}}
"""

def gen_core_modifying_button_effects_code(
    leader_class, trait_name, needs_paragon_dlc=False, 
    is_veteran_trait=False, is_destiny_trait=False,
    required_subclass=None
):
    # This needs to generate two effects: add, and remove
    # xvcv_mdls_button_effects_core_modifying_traits_<LEADER_CLASS>_customgui.txt
    has_paragon_dlc_answer = "yes" if needs_paragon_dlc else "no"
    comment_out_paragon_dlc = "" if needs_paragon_dlc else "#"
    trait_ends_in_num = trait_name[-1].isdigit()
    needs_remove_tier_num_trait_effect = "" if trait_ends_in_num else "#"
    if trait_ends_in_num:
        trait_name_no_tier = trait_name.rsplit('_',1)[0]
    else:
        trait_name_no_tier = trait_name
    # Veteran & destinty traits need slightly altered trigger names
    alt_trigger_name = ""
    if is_veteran_trait:
        alt_trigger_name = "alt_"
    elif is_destiny_trait:
        alt_trigger_name = "alt_2_"
    # Comment out the 'requires_leader_subclass_trigger` if it's not a veteran trait'
    requires_subclass_trigger = "" if is_veteran_trait or is_destiny_trait or required_subclass == "any" else "#"
    # commend out skill level trigger if it's not a veteran trait
    requires_skill_lvl_trigger = "" if is_veteran_trait or is_destiny_trait else "#"
    trait_class = "common"
    if is_veteran_trait:
        trait_class = "veteran"
    elif is_destiny_trait:
        trait_class = "destiny"
    trait_comment = f"#{trait_class} trait"

    return f"""
#{trait_name} {trait_comment}
xvcv_mdlc_core_modifying_traits_{leader_class}_{trait_name}_add_button_effect = {{
    potential = {{
        ruler = {{ NOT = {{ has_trait = {trait_name} }} }}
    }}
    allow = {{
        custom_tooltip = xvcv_mdlc_core_modifying_tooltip_add_{leader_class}_{trait_name}
        {requires_subclass_trigger}xvcv_mdlc_core_modifying_requires_ruler_subclass_or_focus_trigger = {{ CLASS = {leader_class} ID = {required_subclass} }}
        xvcv_mdlc_core_modifying_trait_cost_{alt_trigger_name}trigger = yes
        xvcv_mdlc_core_modifying_trait_points_{alt_trigger_name}trigger = yes
        {requires_skill_lvl_trigger}xvcv_mdlc_core_modifying_trait_skill_level_{alt_trigger_name}trigger = yes
        xvcv_mdlc_core_modifying_trait_max_number_trigger = yes
        {comment_out_paragon_dlc}has_paragon_dlc = {has_paragon_dlc_answer}
    }}
    effect = {{
        {needs_remove_tier_num_trait_effect}xvcv_mdlc_core_modifying_remove_tier_1_or_2_traits_effect = {{ ID = {trait_name_no_tier} }}
        xvcv_mdlc_core_modifying_trait_pick_effect = {{ CLASS = {leader_class} ID = {trait_name} }}
        hidden_effect = {{ xvcv_mdlc_core_modifying_trait_add_{alt_trigger_name}effect = yes }}
    }}
}}
xvcv_mdlc_core_modifying_traits_{leader_class}_{trait_name}_remove_button_effect = {{
    potential = {{
        ruler = {{ has_trait = {trait_name} }}
    }}
    allow = {{ always = yes }}
    effect = {{
        custom_tooltip = xvcv_mdlc_core_modifying_tooltip_remove_{leader_class}_{trait_name}
        hidden_effect = {{
            ruler = {{ remove_trait = {trait_name} }}
            xvcv_mdlc_core_modifying_trait_remove_{alt_trigger_name}effect = yes
        }}
    }}
}}
"""

def iterate_traits_make_coremodifying_gui_code(organized_traits_dict, for_class: str):
    """ The core-modifying GUI sections for leader classes are oddly shaped.
    the 'admiral' section has to have shorter rows than the other sections, but 
    only for the first 3 rows."""

    header_classname_spaced = ' '.join([char for char in for_class])
    header = gui_header.format(
        classname=header_classname_spaced,
        now=str(datetime.now())
    )
    footer = gui_footer.format(
        classname=header_classname_spaced
    )
    gui_code_bloblist = [header,]
    # To accomodate the irregular shape of the container,
    # The first row for Commander has 4, the second row has 5, and the rest are 6 
    row_width_limits = {
        "1": 4,
        "2": 5
    }
    trait_column_num = 1
    trait_row_num = 1
    for rarity_level in RARITIES:
        for leader_trait in organized_traits_dict["core_modifying_traits"][rarity_level]:
            trait_name = [*leader_trait][0]
            root = leader_trait[trait_name]
            trait_gui_code = gen_core_modifying_trait_gui_code(
                leader_class=for_class,
                gfx_sprite_name=root['gfx'],
                trait_name=trait_name,
                column_num=trait_column_num,
                row_num=trait_row_num,
                is_veteran_trait=(root.get('rarity')=="veteran"),
                is_destiny_trait=(root.get('rarity')=="paragon"),
            )
            # Advance the x / y coordinates
            trait_column_num = trait_column_num + 1
            if for_class=="commander":
                # Special maths rules
                if trait_row_num == 1:
                    # Go to the next row after 4 traits
                    if trait_column_num > 5:
                        trait_row_num = trait_row_num + 1
                        trait_column_num = 1
                elif trait_row_num == 2:
                    # Go to the next row after 5 traits
                    if trait_column_num > 6:
                        trait_row_num = trait_row_num + 1
                        trait_column_num = 1
                else:
                    # Permit only 6 traits in a row therafter, like normal
                    if trait_column_num > 7:
                        trait_column_num = 1
                        trait_row_num = trait_row_num + 1
            else:
                # No special x / y rules for the other classes
                if trait_column_num > 10:
                    trait_column_num = 1
                    trait_row_num = trait_row_num + 1
            gui_code_bloblist.append(trait_gui_code)

    gui_code_bloblist.append(footer)
    return ''.join(gui_code_bloblist)

# Generic version (can be used with both leader_making and core_modifying)
def iterate_traits_make_feature_button_effects_code(organized_traits_dict, for_class, feature="leader_making"):
    leader_trait_button_effects_copypaste_blob = [AUTOGENERATED_HEADER]
    for rarity_level in RARITIES:
        for leader_trait in organized_traits_dict['leader_making_traits'][rarity_level]:
            trait_name = [*leader_trait][0]
            root = leader_trait[trait_name]
            if feature == LEADER_MAKING:
                feature_button_effects_code = gen_core_modifying_button_effects_code(
                    leader_class=for_class,
                    trait_name=trait_name,
                    is_veteran_trait=(root.get('rarity')=="veteran"),
                    is_destiny_trait=(root.get('rarity')=="paragon"),
                    required_subclass=root.get('required_subclass', None)
                )
            elif feature == CORE_MODIFYING:
                feature_button_effects_code = gen_core_modifying_button_effects_code(
                    leader_class=for_class,
                    trait_name=trait_name,
                    is_veteran_trait=(root.get('rarity')=="veteran"),
                    is_destiny_trait=(root.get('rarity')=="paragon"),
                    required_subclass=root.get('required_subclass', None)
                )
                
            leader_trait_button_effects_copypaste_blob.append(feature_button_effects_code)
    return '\n'.join(leader_trait_button_effects_copypaste_blob)


    sys.exit("iterate_traits_make_coremodifying_effects_code not implemented yet.")

def gen_xvcv_mdlc_core_modifying_ruler_traits_trigger(organized_traits_dict):
    """ Entire trigger with updated list of 3.10 traits for core modifying. for copy/paste """
    indentation = " "*8
    preamble = """
xvcv_mdlc_core_modifying_ruler_traits_trigger = {
    optimize_memory
    OR = {"""
    closing = """    }
}
"""
    trait_conditions_list = []
    for subclass in LEADER_SUBCLASSES:
        trait_conditions_list.append(
            f"{indentation}has_trait = {subclass}"
        )
    for rarity_level in RARITIES:
        if rarity_level in organized_traits_dict['core_modifying_traits']:
            for leader_trait in organized_traits_dict['core_modifying_traits'][rarity_level]:
                trait_name = [*leader_trait][0]
                trait_conditions_list.append(
                    f"{indentation}has_trait = {trait_name}"
                )
    compiled_trigger = f"""{preamble}
{"\n".join(sorted(trait_conditions_list))}
{closing}"""
    return compiled_trigger

def gen_xvcv_mdlc_leader_making_clear_values_effect():
    """ Print out the entire 'xvcv_mdlc_leader_making_clear_values_effect' 
    For this we have to iterate subclasses, traits, and print updated trigger for copy/paste
    It's a bit much to do by hand, and we already have the data, so let's priinttttt
    """
    preamble = """
xvcv_mdlc_leader_making_clear_values_effect = {
    optimize_memory
    if = {
        limit = { xvcv_mdlc_leader_making_picked_any_skill_level_trigger = yes }
        xvcv_mdlc_leader_making_clear_skill_levels_effect = yes
    }"""
    closing = """    xvcv_mdlc_leader_making_clear_traits_variables_effect = yes
}
"""
    """ This effect has 3 conditionals at the top-level, for each class,
    and inside of each block of conditionals, it has that class' traits
    We will have to iterate the 3 data files in this single method
    """
    large_if_clauses_for_all_classes = []
    for input_codegen_json_file_name in INPUT_FILES_FOR_CODEGEN:
        # Go over the files, do all common/veteran/paragon traits for each class
        input_file_path = os.path.join(BUILD_FOLDER, input_codegen_json_file_name)
        buffer = ''
        with open(input_file_path, "r") as source_codegen_data:
            buffer = json_load(source_codegen_data)
        leader_class = input_codegen_json_file_name.split('_')[2]
        class_specific_if_limit_then_clear_lines = generate_class_specific_lines_for_leader_making_clear_values_effect(
            buffer, for_class=leader_class
        )
        large_if_clauses_for_all_classes.append(class_specific_if_limit_then_clear_lines)
    compiled_trigger = f"""{preamble}
{"".join(sorted(large_if_clauses_for_all_classes))}
{closing}"""
    return compiled_trigger

def generate_class_specific_lines_for_leader_making_clear_values_effect(organized_traits_dict, for_class="commander"):
    # TODO: Exclude core_modifying traits that we dont want ?

    opening_lines = f"""
    #{for_class}
    if = {{
        limit = {{ has_country_flag = xvcv_mdlc_leader_class_set_to_{for_class} }}"""
    closing_lines = f"""        remove_country_flag = xvcv_mdlc_leader_class_set_to_{for_class}
    }}"""
    trait_limit_declarations = []
    for rarity_level in RARITIES:
        if organized_traits_dict['core_modifying_traits'].get(rarity_level):
            for leader_trait in organized_traits_dict['core_modifying_traits'][rarity_level]:
                trait_name = [*leader_trait][0]
                trait_limit_line = f"        if = {{ limit = {{ has_country_flag = xvcv_mdlc_leader_{for_class}_{trait_name} }} remove_country_flag = xvcv_mdlc_leader_{for_class}_{trait_name} }}"
                trait_limit_declarations.append(trait_limit_line)
    # Preserve this during autogeneration
    add_custom_traits_class_block = f"""
        if = {{ limit = {{ has_country_flag = xvcv_mdlc_leader_{for_class}_xvcv_mdlc_leader_trait_memory_backup }} remove_country_flag = xvcv_mdlc_leader_{for_class}_xvcv_mdlc_leader_trait_memory_backup }}
        if = {{ limit = {{ has_country_flag = xvcv_mdlc_leader_{for_class}_xvcv_mdlc_leader_trait_shared_memory }} remove_country_flag = xvcv_mdlc_leader_{for_class}_xvcv_mdlc_leader_trait_shared_memory }}
        if = {{ limit = {{ has_country_flag = xvcv_mdlc_leader_{for_class}_xvcv_mdlc_subclass_{for_class}_none }} remove_country_flag = xvcv_mdlc_leader_{for_class}_xvcv_mdlc_subclass_{for_class}_none }}"""
    trait_limit_declarations.append(add_custom_traits_class_block)
    class_specific_clear_values_lines = f"""{opening_lines}{"\n".join(sorted(trait_limit_declarations))}
{closing_lines}"""
    return class_specific_clear_values_lines

def generate_coremodifying_feature_code():
    """ This process will make 3 sets of the below files for each leader class, so 18 in total:
        Replacing 'commander' with 'official and 'scientist' for the other 2 sets.

        86_mre_autogenerated_commander_core_modifying_gui.txt
        86_mre_autogenerated_commander_core_modifying_effects.txt
        86_mre_autogenerated_commander_core_modifying_tooltips.txt
        86_mre_autogenerated_commander_leader_making_gui.txt
        86_mre_autogenerated_commander_leader_making_effects.txt
        86_mre_autogenerated_commander_leader_making_tooltips.txt

        Effects and tooltips files can directly replace game mod files,
        but only the code in each gui.txt file needs to be copy/pasted into its destination.
    """
    """ TODO: Deposit localisation and button effects directly into their game code files """
    for input_file in INPUT_FILES_FOR_CODEGEN:
        for feature_type in (LEADER_MAKING, CORE_MODIFYING):
            for generated_code_type in ["effects","gui","tooltips"]:
                run_codegen_process_for_ingame_feature(
                    input_file, generated_code_type=generated_code_type, feature=feature_type
                )


# Generic version
def iterate_traits_make_feature_tooltips_code(organized_traits_dict, for_class, feature="leader_making"):
    """ Generate tooltips code for either 'leader_making' or 'core_modifying' feature """
    leader_tooltips_copypaste_blob = [AUTOGENERATED_HEADER]
    for rarity_level in RARITIES:
        for leader_trait in organized_traits_dict[f"{feature}_traits"][rarity_level]:
            tooltip_code_for_leadermaking_trait = create_tooltip_for_leader(
                trait_dict=leader_trait, leader_class=for_class, feature=feature
            )
            leader_tooltips_copypaste_blob.append(tooltip_code_for_leadermaking_trait)
    return ''.join(leader_tooltips_copypaste_blob)

# Generic version
def run_codegen_process_for_ingame_feature(
    input_codegen_json_file_name,
    generated_code_type,
    feature="core_modifying"
):
    """ Do all code gen for the core_modifying feature """
    buffer = ''
    base_filename =  input_codegen_json_file_name.rsplit('.',1)[0]
    detected_leader_class = input_codegen_json_file_name.split('_')[2]
    leadermaking_code_outfile = f"86_mre_autogenerated_{detected_leader_class}_{feature}_{generated_code_type}.txt"
    output_file_name = os.path.join(
        BUILD_FOLDER,
        leadermaking_code_outfile
    )
    input_file_path = os.path.join(BUILD_FOLDER, input_codegen_json_file_name)
    with open(input_file_path, "r") as source_codegen_data:
        buffer = json_load(source_codegen_data)
    
    generated_leadermaking_code_blob = ''
    if generated_code_type == "tooltips":
        # This method works for both core_modifying and leader_making
        generated_leadermaking_code_blob = iterate_traits_make_feature_tooltips_code(
            buffer,
            for_class=detected_leader_class,
            feature=feature
        )
    elif generated_code_type == "gui":
        if feature == "core_modifying":
            generated_leadermaking_code_blob = iterate_traits_make_coremodifying_gui_code(
                buffer,
                for_class=detected_leader_class
            )
        elif feature == "leader_making":
            generated_leadermaking_code_blob = iterate_traits_make_leadermaking_gui_code(
                buffer,
                for_class=detected_leader_class
            )
    elif generated_code_type == "effects":
        generated_leadermaking_code_blob = iterate_traits_make_feature_button_effects_code(
            buffer,
            for_class=detected_leader_class,
            feature=feature
        )
    with open(output_file_name, "wb") as leadermaking_code_outfile:
        sys.stdout.write(f"Writing {detected_leader_class} {feature} {generated_code_type} code to {output_file_name}\n")
        leadermaking_code_outfile.write(
            generated_leadermaking_code_blob.encode('utf-8')
        )


if __name__ == "__main__":
    start_time = time.time()
    parser = argparse.ArgumentParser(
        prog="0xRetro Machine & Robot Expansion Mod Codegen Tools",
        description="Automatically spew out mod code"
    )
    parser.add_argument(
        '--infile',
        help='A traits JSON file that we processed, like 99_mre_commander_traits_for_codegen.json, created from mre_process_traits_for_codegen.py.',
        required=True
    )
    parser.add_argument(
        '--leadermaking',
        help="Specify to make tooltips, effects, and gui code for the leadermaking feature. Use this arg by itself.",
        required=False
    )
    parser.add_argument(
        '--coremodifying',
        help="Specify to make tooltips, effects, and gui code for the 'core modifying' feature. Use this arg by itself.",
        required=False,
        action="store_true"
    )
    parser.add_argument(
        '--tooltips',
        help="Generate M&RE trait tooltips, given a traits JSON file that was processed by mre_process_traits_for_codegen",
        action="store_true",
        required=False
    )
    parser.add_argument(
        '--effects',
        help="Generate effects code from trait files",
        action="store_true",
        required=False
    )
    parser.add_argument(
        '--gui',
        help="Generate GUI code for leadermaking feature, from trait files",
        action="store_true",
        required=False
    )
    parser.add_argument(
        '--process_all',
        help="The Big One. Generate M&RE tooltips, GUI code, button effects code, assuming all traits files were processed by mre_process_traits_for_codegen"
    )
    args = parser.parse_args()
    buffer = ''
    infile_no_ext = args.infile.rsplit('.',1)[0]
    with open(args.infile) as organized_traits_file:
        buffer = json_load(organized_traits_file)
    # if args.leadermaking:
    #     """ Generate and write all 3 types of code for the leader-making feature """
    if args.coremodifying:
        generate_coremodifying_feature_code()
        sys.exit()
        
    if args.tooltips:
        target_file = f"{infile_no_ext}_leadermaking_tooltips.txt"
        detected_leader_class = args.infile.split('_')[2]
        tooltips_blob_for_writing = iterate_traits_make_leadermaking_tooltips_code(
            buffer, for_class=detected_leader_class)
        with open(target_file, "wb") as leadermaking_effects_output:
            sys.stdout.write(f"Writing leadermaking tooltips code to {leadermaking_effects_output.name}\n")
            leadermaking_effects_output.write(
                tooltips_blob_for_writing.encode('utf-8')
            )
        sys.exit()
    if args.effects:
        detected_leader_class = args.infile.split('_')[2]
        effects_blob_for_writing = iterate_traits_make_leadermaking_effects_code(
            buffer, for_class=detected_leader_class)
        with open(f"{infile_no_ext}_leadermaking_effects.txt", "wb") as leadermaking_effects_output:
            sys.stdout.write(f"Writing leadermaking effects code to {leadermaking_effects_output.name}\n")
            leadermaking_effects_output.write(
                effects_blob_for_writing.encode('utf-8')
            )
            sys.exit()
    if args.gui:
        detected_leader_class = args.infile.split('_')[2]
        gui_blob_for_writing = iterate_traits_make_leadermaking_gui_code(
            buffer, for_class=detected_leader_class)
        with open(f"{infile_no_ext}_leadermaking_gui.txt", "wb") as leadermaking_gui_output:
            sys.stdout.write(f"Writing leadermaking gui code to {leadermaking_gui_output.name}\n")
            leadermaking_gui_output.write(
                gui_blob_for_writing.encode('utf-8')
            )
            sys.exit()

